/// logical implementations using only NAND chip + manually constructed chips
pub mod hardware {
    pub mod logic_gate {
        pub mod alu;
        pub mod arithmetic;
        pub mod cpu;
        pub mod gates;
        pub mod memory;
    }

    /// shortcut implementations in native rust to speed up processing
    pub mod native {
        pub mod alu;
        pub mod cpu;
        pub mod gates;
        pub mod instructions;
        pub mod memory;
    }
}

pub mod software {
    pub mod assembler;
}

pub mod utils {
    // kinda disgusting but it'll do.
    pub fn bitvec_from_int(mut int: u16) -> Vec<u8> {
        let mut result = Vec::new();
        for _ in 0..16 {
            result.push((int & 0b0000_0000_0000_0001) as u8);
            int = int >> 1;
        }
        result.into_iter().rev().collect()
    }

    pub fn int_from_bitvec(vec: &Vec<u8>) -> u16 {
        let mut result: u16 = 0;
        for (i, j) in vec.into_iter().enumerate() {
            result |= (*j) as u16;
            if i < vec.len() - 1 {
                result = result << 1;
            }
        }
        result
    }

    pub fn decode_bitvec_instr(instr: &Vec<u8>) {
        // form: [i, i, i, a, c1, c2, c3, c4, c5, c6, d1, d2, d3, j1, j2, j3]
        let mut a_or_c = match instr[0] {
            0 => {
                println!(
                    "a instr: load value {} into A register",
                    int_from_bitvec(instr)
                );
                return;
            }
            1 => "c instr",
            _ => "Error",
        };

        let a_or_m = match instr[3] {
            0 => "using value of A as val",
            1 => "using RAM[A] as val",
            _ => "Error",
        };

        let cmp = match instr[4..10] {
            [1, 0, 1, 0, 1, 0] => "0",
            [1, 1, 1, 1, 1, 1] => "1",
            [1, 1, 1, 0, 1, 0] => "-1",
            [0, 0, 1, 1, 0, 0] => "D",
            [1, 1, 0, 0, 0, 0] => "val",
            [0, 0, 1, 1, 0, 1] => "!D",
            [1, 1, 0, 0, 0, 1] => "!val",
            [0, 0, 1, 1, 1, 1] => "minus D",
            [1, 1, 0, 0, 1, 1] => "minus val",
            [0, 1, 1, 1, 1, 1] => "D + 1",
            [1, 1, 0, 1, 1, 1] => "val + 1",
            [0, 0, 1, 1, 1, 0] => "D - 1",
            [1, 1, 0, 0, 1, 0] => "val - 1",
            [0, 0, 0, 0, 1, 0] => "D + val",
            [0, 1, 0, 0, 1, 1] => "D - val",
            [0, 0, 0, 1, 1, 1] => "val - D",
            [0, 0, 0, 0, 0, 0] => "D & val",
            [0, 1, 0, 1, 0, 1] => "D | val",
            _ => "Error",
        };

        let store_in = match instr[10..13] {
            [0, 0, 0] => "None",
            [0, 0, 1] => "RAM[A]",
            [0, 1, 0] => "D",
            [0, 1, 1] => "D and RAM[A]",
            [1, 0, 0] => "A",
            [1, 0, 1] => "A and RAM[A]",
            [1, 1, 0] => "A and D",
            [1, 1, 1] => "A, D, and RAM[A]",
            _ => "Error",
        };

        let jump = match instr[13..=15] {
            [0, 0, 0] => "Never",
            [0, 0, 1] => "If greater than",
            [0, 1, 0] => "If equal",
            [0, 1, 1] => "If greater than or equal",
            [1, 0, 0] => "If less than",
            [1, 0, 1] => "If not equal",
            [1, 1, 0] => "If less than or equal",
            [1, 1, 1] => "Always",
            _ => "Error",
        };

        println!("{a_or_c}: {a_or_m}, compute '{cmp}' and store the value in {store_in}. {jump} jump to ROM[A].")
    }

    pub fn decode_instr(instr: u16) {
        if instr & 0b1000_0000_0000_0000 == 0 {
            println!(
                "load value {} into A register",
                instr & 0b0111_1111_1111_1111
            );
            return;
        }
        let a_or_m = match instr & 0b0001_0000_0000_0000 > 0 {
            false => "using value of A as val",
            true => "using RAM[A] as val",
        };
        let cmp = match (instr & 0b0000_1111_1100_0000) >> 6 {
            0b0000_0000_0010_1010 => "0",
            0b0000_0000_0011_1111 => "1",
            0b0000_0000_0011_1010 => "-1",
            0b0000_0000_0000_1100 => "D",
            0b0000_0000_0011_0000 => "val",
            0b0000_0000_0000_1101 => "!D",
            0b0000_0000_0011_0001 => "!val",
            0b0000_0000_0000_1111 => "minus D",
            0b0000_0000_0011_0011 => "minus val",
            0b0000_0000_0001_1111 => "D + 1",
            0b0000_0000_0011_0111 => "val + 1",
            0b0000_0000_0000_1110 => "D - 1",
            0b0000_0000_0011_0010 => "val - 1",
            0b0000_0000_0000_0010 => "D + val",
            0b0000_0000_0001_0011 => "D - val",
            0b0000_0000_0000_0111 => "val - D",
            0b0000_0000_0000_0000 => "D & val",
            0b0000_0000_0001_0101 => "D | val",
            _ => "Error",
        };

        let store_in = match (instr & 0b0000_0000_0011_1000) >> 3 {
            0 => "None",
            1 => "RAM[A]",
            2 => "D",
            3 => "D and RAM[A]",
            4 => "A",
            5 => "A and RAM[A]",
            6 => "A and D",
            7 => "A, D, and RAM[A]",
            _ => "Error",
        };

        let jump = match instr & 0b0000_0000_0000_0111 {
            0 => "Never",
            1 => "If greater than",
            2 => "If equal",
            3 => "If greater than or equal",
            4 => "If less than",
            5 => "If not equal",
            6 => "If less than or equal",
            7 => "Always",
            _ => "Error",
        };

        println!(
            "{a_or_m}, compute '{cmp}' and store the value in {store_in}. {jump} jump to ROM[A]."
        )
    }
}

#[cfg(test)]
mod test {
    use crate::hardware::logic_gate::alu::*;
    use crate::hardware::logic_gate::arithmetic::*;
    use crate::hardware::logic_gate::cpu::*;
    use crate::hardware::logic_gate::gates::*;
    use crate::hardware::logic_gate::memory::*;
    use crate::utils::int_from_bitvec;

    #[test]
    fn test_nand() {
        assert_eq!(truth_table(NAND), [[1, 1], [1, 0]])
    }

    #[test]
    fn test_not() {
        assert_eq!(NOT(0), 1);
        assert_eq!(NOT(1), 0);
    }

    #[test]
    fn test_multi_not() {
        assert_eq!(
            multi_NOT(&vec![0, 0, 0, 0, 1, 1, 1, 1]),
            vec![1, 1, 1, 1, 0, 0, 0, 0]
        )
    }

    #[test]
    fn test_and() {
        assert_eq!(truth_table(AND), [[0, 0], [0, 1]])
    }

    #[test]
    fn test_multi_and() {
        assert_eq!(
            multi_AND(&vec![0, 0, 1, 1], &vec![0, 1, 0, 1]),
            vec![0, 0, 0, 1]
        )
    }

    #[test]
    fn test_or() {
        assert_eq!(truth_table(OR), [[0, 1], [1, 1]]);
    }

    // #[test]
    // fn test_multi_or() {

    // }

    #[test]
    fn test_xor() {
        assert_eq!(truth_table(XOR), [[0, 1], [1, 0]]);
    }

    // #[test]
    // fn test_multi_xor() {

    // }

    #[test]
    fn test_mux() {
        assert_eq!(multi_truth_table(MUX), [0, 0, 1, 1, 0, 1, 0, 1]);
        assert_eq!(MUX(0, 0, 0), 0);
        assert_eq!(MUX(0, 0, 1), 0);
        assert_eq!(MUX(0, 1, 0), 0);
        assert_eq!(MUX(1, 0, 1), 0);

        assert_eq!(MUX(0, 1, 1), 1);
        assert_eq!(MUX(1, 0, 0), 1);
        assert_eq!(MUX(1, 1, 0), 1);
        assert_eq!(MUX(1, 1, 1), 1);
    }

    #[test]
    fn test_mux_4() {
        assert_eq!(MUX_4(0, 0, 0, 0, 0, 0), 0);
        assert_eq!(MUX_4(0, 0, 0, 0, 0, 1), 0);
        assert_eq!(MUX_4(0, 0, 0, 0, 1, 0), 0);
        assert_eq!(MUX_4(0, 0, 0, 0, 1, 1), 0);

        assert_eq!(MUX_4(1, 0, 0, 0, 0, 0), 1);
        assert_eq!(MUX_4(0, 1, 0, 0, 0, 1), 1);
        assert_eq!(MUX_4(0, 0, 1, 0, 1, 0), 1);
        assert_eq!(MUX_4(0, 0, 0, 1, 1, 1), 1);
    }

    #[test]
    fn test_multi_mux_4() {
        assert_eq!(
            multi_MUX_4(
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                0,
                0
            ),
            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        );
        assert_eq!(
            multi_MUX_4(
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                0,
                1
            ),
            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        );
        assert_eq!(
            multi_MUX_4(
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                1,
                0
            ),
            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        );
        assert_eq!(
            multi_MUX_4(
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                1,
                1
            ),
            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        );
        assert_eq!(
            multi_MUX_4(
                &vec![0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0],
                &vec![1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0],
                &vec![1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0],
                &vec![0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1],
                0,
                0
            ),
            vec![0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0]
        );
        assert_eq!(
            multi_MUX_4(
                &vec![0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0],
                &vec![1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0],
                &vec![1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0],
                &vec![0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1],
                0,
                1
            ),
            vec![1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0]
        );
        assert_eq!(
            multi_MUX_4(
                &vec![0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0],
                &vec![1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0],
                &vec![1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0],
                &vec![0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1],
                1,
                0
            ),
            vec![1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]
        );
        assert_eq!(
            multi_MUX_4(
                &vec![0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0],
                &vec![1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0],
                &vec![1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0],
                &vec![0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1],
                1,
                1
            ),
            vec![0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1]
        );
    }

    #[test]
    fn test_multi_mux_8() {
        assert_eq!(
            multi_MUX_8(
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                0,
                0,
                0
            ),
            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        );
        assert_eq!(
            multi_MUX_8(
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                0,
                0,
                1
            ),
            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        );
        assert_eq!(
            multi_MUX_8(
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                0,
                1,
                0
            ),
            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        );
        assert_eq!(
            multi_MUX_8(
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                0,
                1,
                1
            ),
            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        );
        assert_eq!(
            multi_MUX_8(
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                1,
                0,
                0
            ),
            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        );
        assert_eq!(
            multi_MUX_8(
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                1,
                0,
                1
            ),
            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        );
        assert_eq!(
            multi_MUX_8(
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                1,
                1,
                0
            ),
            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        );
        assert_eq!(
            multi_MUX_8(
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                1,
                1,
                1
            ),
            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        );
        assert_eq!(
            multi_MUX_8(
                &vec![0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0],
                &vec![0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1],
                &vec![0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0],
                &vec![0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1],
                &vec![0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0],
                &vec![0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1],
                &vec![0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0],
                &vec![1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1],
                0,
                0,
                0
            ),
            vec![0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0]
        );
        assert_eq!(
            multi_MUX_8(
                &vec![0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0],
                &vec![0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1],
                &vec![0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0],
                &vec![0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1],
                &vec![0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0],
                &vec![0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1],
                &vec![0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0],
                &vec![1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1],
                0,
                0,
                1
            ),
            vec![0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1]
        );
        assert_eq!(
            multi_MUX_8(
                &vec![0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0],
                &vec![0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1],
                &vec![0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0],
                &vec![0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1],
                &vec![0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0],
                &vec![0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1],
                &vec![0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0],
                &vec![1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1],
                0,
                1,
                0
            ),
            vec![0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0]
        );
        assert_eq!(
            multi_MUX_8(
                &vec![0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0],
                &vec![0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1],
                &vec![0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0],
                &vec![0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1],
                &vec![0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0],
                &vec![0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1],
                &vec![0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0],
                &vec![1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1],
                0,
                1,
                1
            ),
            vec![0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1]
        );
        assert_eq!(
            multi_MUX_8(
                &vec![0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0],
                &vec![0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1],
                &vec![0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0],
                &vec![0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1],
                &vec![0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0],
                &vec![0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1],
                &vec![0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0],
                &vec![1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1],
                1,
                0,
                0
            ),
            vec![0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0]
        );
        assert_eq!(
            multi_MUX_8(
                &vec![0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0],
                &vec![0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1],
                &vec![0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0],
                &vec![0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1],
                &vec![0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0],
                &vec![0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1],
                &vec![0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0],
                &vec![1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1],
                1,
                0,
                1
            ),
            vec![0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1]
        );
        assert_eq!(
            multi_MUX_8(
                &vec![0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0],
                &vec![0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1],
                &vec![0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0],
                &vec![0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1],
                &vec![0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0],
                &vec![0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1],
                &vec![0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0],
                &vec![1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1],
                1,
                1,
                0
            ),
            vec![0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0]
        );
        assert_eq!(
            multi_MUX_8(
                &vec![0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0],
                &vec![0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1],
                &vec![0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0],
                &vec![0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1],
                &vec![0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0],
                &vec![0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1],
                &vec![0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0],
                &vec![1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1],
                1,
                1,
                1
            ),
            vec![1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1]
        );
    }

    #[test]
    fn test_demux() {
        assert_eq!(DEMUX(1, 0), [1, 0]);
        assert_eq!(DEMUX(1, 1), [0, 1]);
        assert_eq!(DEMUX(0, 0), [0, 0]);
        assert_eq!(DEMUX(0, 1), [0, 0]);
    }

    #[test]
    fn test_demux_4() {
        assert_eq!(DEMUX_4(0, 0, 0), [0, 0, 0, 0]);
        assert_eq!(DEMUX_4(0, 0, 1), [0, 0, 0, 0]);
        assert_eq!(DEMUX_4(0, 1, 0), [0, 0, 0, 0]);
        assert_eq!(DEMUX_4(0, 1, 1), [0, 0, 0, 0]);
        assert_eq!(DEMUX_4(1, 0, 0), [1, 0, 0, 0]);
        assert_eq!(DEMUX_4(1, 0, 1), [0, 1, 0, 0]);
        assert_eq!(DEMUX_4(1, 1, 0), [0, 0, 1, 0]);
        assert_eq!(DEMUX_4(1, 1, 1), [0, 0, 0, 1]);
    }

    #[test]
    fn test_multi_demux_4() {
        assert_eq!(
            multi_DEMUX_4(&vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 0, 0),
            [
                vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
            ]
        );
        assert_eq!(
            multi_DEMUX_4(&vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 0, 1),
            [
                vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
            ]
        );
        assert_eq!(
            multi_DEMUX_4(&vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 1, 0),
            [
                vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
            ]
        );
        assert_eq!(
            multi_DEMUX_4(&vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], 1, 1),
            [
                vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
            ]
        );
        assert_eq!(
            multi_DEMUX_4(&vec![0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0], 0, 0),
            [
                vec![0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0],
                vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
            ]
        );
        assert_eq!(
            multi_DEMUX_4(&vec![1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0], 0, 1),
            [
                vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                vec![1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0],
                vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
            ]
        );
        assert_eq!(
            multi_DEMUX_4(&vec![1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0], 1, 0),
            [
                vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                vec![1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0],
                vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
            ]
        );
        assert_eq!(
            multi_DEMUX_4(&vec![0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1], 1, 1),
            [
                vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                vec![0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1]
            ]
        );
    }

    #[test]
    fn test_demux_8() {
        assert_eq!(DEMUX_8(0, 0, 0, 0), [0, 0, 0, 0, 0, 0, 0, 0]);
        assert_eq!(DEMUX_8(0, 0, 0, 1), [0, 0, 0, 0, 0, 0, 0, 0]);
        assert_eq!(DEMUX_8(0, 0, 1, 0), [0, 0, 0, 0, 0, 0, 0, 0]);
        assert_eq!(DEMUX_8(0, 0, 1, 1), [0, 0, 0, 0, 0, 0, 0, 0]);
        assert_eq!(DEMUX_8(0, 1, 0, 0), [0, 0, 0, 0, 0, 0, 0, 0]);
        assert_eq!(DEMUX_8(0, 1, 0, 1), [0, 0, 0, 0, 0, 0, 0, 0]);
        assert_eq!(DEMUX_8(0, 1, 1, 0), [0, 0, 0, 0, 0, 0, 0, 0]);
        assert_eq!(DEMUX_8(0, 1, 1, 1), [0, 0, 0, 0, 0, 0, 0, 0]);

        assert_eq!(DEMUX_8(1, 0, 0, 0), [1, 0, 0, 0, 0, 0, 0, 0]);
        assert_eq!(DEMUX_8(1, 0, 0, 1), [0, 1, 0, 0, 0, 0, 0, 0]);
        assert_eq!(DEMUX_8(1, 0, 1, 0), [0, 0, 1, 0, 0, 0, 0, 0]);
        assert_eq!(DEMUX_8(1, 0, 1, 1), [0, 0, 0, 1, 0, 0, 0, 0]);
        assert_eq!(DEMUX_8(1, 1, 0, 0), [0, 0, 0, 0, 1, 0, 0, 0]);
        assert_eq!(DEMUX_8(1, 1, 0, 1), [0, 0, 0, 0, 0, 1, 0, 0]);
        assert_eq!(DEMUX_8(1, 1, 1, 0), [0, 0, 0, 0, 0, 0, 1, 0]);
        assert_eq!(DEMUX_8(1, 1, 1, 1), [0, 0, 0, 0, 0, 0, 0, 1]);
    }

    #[test]
    fn test_half_adder() {
        assert_eq!(half_adder(0, 0), Add { sum: 0, carry: 0 });
        assert_eq!(half_adder(0, 1), Add { sum: 1, carry: 0 });
        assert_eq!(half_adder(1, 0), Add { sum: 1, carry: 0 });
        assert_eq!(half_adder(1, 1), Add { sum: 0, carry: 1 });
    }

    #[test]
    fn test_full_adder() {
        assert_eq!(full_adder(0, 0, 0), Add { sum: 0, carry: 0 });
        assert_eq!(full_adder(0, 0, 1), Add { sum: 1, carry: 0 });
        assert_eq!(full_adder(0, 1, 0), Add { sum: 1, carry: 0 });
        assert_eq!(full_adder(0, 1, 1), Add { sum: 0, carry: 1 });
        assert_eq!(full_adder(1, 0, 0), Add { sum: 1, carry: 0 });
        assert_eq!(full_adder(1, 0, 1), Add { sum: 0, carry: 1 });
        assert_eq!(full_adder(1, 1, 0), Add { sum: 0, carry: 1 });
        assert_eq!(full_adder(1, 1, 1), Add { sum: 1, carry: 1 });
    }

    #[test]
    fn test_adder() {
        assert_eq!(
            adder(
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
            ),
            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        );
        assert_eq!(
            adder(
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
            ),
            vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        );
        assert_eq!(
            adder(
                &vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                &vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
            ),
            vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0]
        );
        assert_eq!(
            adder(
                &vec![1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0],
                &vec![0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1]
            ),
            vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        );
        assert_eq!(
            adder(
                &vec![0, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1],
                &vec![0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0]
            ),
            vec![0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1]
        );
        assert_eq!(
            adder(
                &vec![0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0],
                &vec![1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0]
            ),
            vec![1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]
        );
    }
    #[test]
    fn test_incrementer() {
        assert_eq!(
            incrementer(&vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]
        );
        assert_eq!(
            incrementer(&vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]),
            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        );
        assert_eq!(
            incrementer(&vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1]),
            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0]
        );
        assert_eq!(
            incrementer(&vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1]),
            vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0]
        );
    }

    #[test]
    fn test_alu() {
        assert_eq!(
            ALU(
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                &mut ControlBits {
                    zx: 1,
                    nx: 0,
                    zy: 1,
                    ny: 0,
                    f: 1,
                    no: 0,
                    zr: 0,
                    ng: 0
                }
            ),
            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        );
        assert_eq!(
            ALU(
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                &mut ControlBits {
                    zx: 1,
                    nx: 1,
                    zy: 1,
                    ny: 1,
                    f: 1,
                    no: 1,
                    zr: 0,
                    ng: 0
                }
            ),
            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]
        );
        assert_eq!(
            ALU(
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                &mut ControlBits {
                    zx: 1,
                    nx: 1,
                    zy: 1,
                    ny: 0,
                    f: 1,
                    no: 0,
                    zr: 0,
                    ng: 0
                }
            ),
            vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        );
        assert_eq!(
            ALU(
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                &mut ControlBits {
                    zx: 0,
                    nx: 0,
                    zy: 1,
                    ny: 1,
                    f: 0,
                    no: 0,
                    zr: 0,
                    ng: 0
                }
            ),
            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        );
        assert_eq!(
            ALU(
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                &mut ControlBits {
                    zx: 1,
                    nx: 1,
                    zy: 0,
                    ny: 0,
                    f: 0,
                    no: 0,
                    zr: 0,
                    ng: 0
                }
            ),
            vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        );
        assert_eq!(
            ALU(
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                &mut ControlBits {
                    zx: 0,
                    nx: 0,
                    zy: 1,
                    ny: 1,
                    f: 0,
                    no: 1,
                    zr: 0,
                    ng: 0
                }
            ),
            vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        );
        assert_eq!(
            ALU(
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                &mut ControlBits {
                    zx: 1,
                    nx: 1,
                    zy: 0,
                    ny: 0,
                    f: 0,
                    no: 1,
                    zr: 0,
                    ng: 0
                }
            ),
            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        );
        assert_eq!(
            ALU(
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                &mut ControlBits {
                    zx: 0,
                    nx: 0,
                    zy: 1,
                    ny: 1,
                    f: 1,
                    no: 1,
                    zr: 0,
                    ng: 0
                }
            ),
            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        );
        assert_eq!(
            ALU(
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                &mut ControlBits {
                    zx: 1,
                    nx: 1,
                    zy: 0,
                    ny: 0,
                    f: 1,
                    no: 1,
                    zr: 0,
                    ng: 0
                }
            ),
            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]
        );
        assert_eq!(
            ALU(
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                &mut ControlBits {
                    zx: 0,
                    nx: 1,
                    zy: 1,
                    ny: 1,
                    f: 1,
                    no: 1,
                    zr: 0,
                    ng: 0
                }
            ),
            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]
        );
        assert_eq!(
            ALU(
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                &mut ControlBits {
                    zx: 1,
                    nx: 1,
                    zy: 0,
                    ny: 1,
                    f: 1,
                    no: 1,
                    zr: 0,
                    ng: 0
                }
            ),
            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        );
        assert_eq!(
            ALU(
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                &mut ControlBits {
                    zx: 0,
                    nx: 0,
                    zy: 1,
                    ny: 1,
                    f: 1,
                    no: 0,
                    zr: 0,
                    ng: 0
                }
            ),
            vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        );
        assert_eq!(
            ALU(
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                &mut ControlBits {
                    zx: 1,
                    nx: 1,
                    zy: 0,
                    ny: 0,
                    f: 1,
                    no: 0,
                    zr: 0,
                    ng: 0
                }
            ),
            vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0]
        );
        assert_eq!(
            ALU(
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                &mut ControlBits {
                    zx: 0,
                    nx: 0,
                    zy: 0,
                    ny: 0,
                    f: 1,
                    no: 0,
                    zr: 0,
                    ng: 0
                }
            ),
            vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        );
        assert_eq!(
            ALU(
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                &mut ControlBits {
                    zx: 0,
                    nx: 1,
                    zy: 0,
                    ny: 0,
                    f: 1,
                    no: 1,
                    zr: 0,
                    ng: 0
                }
            ),
            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]
        );
        assert_eq!(
            ALU(
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                &mut ControlBits {
                    zx: 0,
                    nx: 0,
                    zy: 0,
                    ny: 1,
                    f: 1,
                    no: 1,
                    zr: 0,
                    ng: 0
                }
            ),
            vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        );
        assert_eq!(
            ALU(
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                &mut ControlBits {
                    zx: 0,
                    nx: 0,
                    zy: 0,
                    ny: 0,
                    f: 0,
                    no: 0,
                    zr: 0,
                    ng: 0
                }
            ),
            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        );
        assert_eq!(
            ALU(
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                &vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                &mut ControlBits {
                    zx: 0,
                    nx: 1,
                    zy: 0,
                    ny: 1,
                    f: 0,
                    no: 1,
                    zr: 0,
                    ng: 0
                }
            ),
            vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        );
        assert_eq!(
            ALU(
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1],
                &mut ControlBits {
                    zx: 1,
                    nx: 0,
                    zy: 1,
                    ny: 0,
                    f: 1,
                    no: 0,
                    zr: 0,
                    ng: 0
                }
            ),
            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
        );
        assert_eq!(
            ALU(
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1],
                &mut ControlBits {
                    zx: 1,
                    nx: 1,
                    zy: 1,
                    ny: 1,
                    f: 1,
                    no: 1,
                    zr: 0,
                    ng: 0
                }
            ),
            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]
        );
        assert_eq!(
            ALU(
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1],
                &mut ControlBits {
                    zx: 1,
                    nx: 1,
                    zy: 1,
                    ny: 0,
                    f: 1,
                    no: 0,
                    zr: 0,
                    ng: 0
                }
            ),
            vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
        );
        assert_eq!(
            ALU(
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1],
                &mut ControlBits {
                    zx: 0,
                    nx: 0,
                    zy: 1,
                    ny: 1,
                    f: 0,
                    no: 0,
                    zr: 0,
                    ng: 0
                }
            ),
            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1]
        );
        assert_eq!(
            ALU(
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1],
                &mut ControlBits {
                    zx: 1,
                    nx: 1,
                    zy: 0,
                    ny: 0,
                    f: 0,
                    no: 0,
                    zr: 0,
                    ng: 0
                }
            ),
            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1]
        );
        assert_eq!(
            ALU(
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1],
                &mut ControlBits {
                    zx: 0,
                    nx: 0,
                    zy: 1,
                    ny: 1,
                    f: 0,
                    no: 1,
                    zr: 0,
                    ng: 0
                }
            ),
            vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0]
        );
        assert_eq!(
            ALU(
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1],
                &mut ControlBits {
                    zx: 1,
                    nx: 1,
                    zy: 0,
                    ny: 0,
                    f: 0,
                    no: 1,
                    zr: 0,
                    ng: 0
                }
            ),
            vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0]
        );
        assert_eq!(
            ALU(
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1],
                &mut ControlBits {
                    zx: 0,
                    nx: 0,
                    zy: 1,
                    ny: 1,
                    f: 1,
                    no: 1,
                    zr: 0,
                    ng: 0
                }
            ),
            vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1]
        );
        assert_eq!(
            ALU(
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1],
                &mut ControlBits {
                    zx: 1,
                    nx: 1,
                    zy: 0,
                    ny: 0,
                    f: 1,
                    no: 1,
                    zr: 0,
                    ng: 0
                }
            ),
            vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1]
        );
        assert_eq!(
            ALU(
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1],
                &mut ControlBits {
                    zx: 0,
                    nx: 1,
                    zy: 1,
                    ny: 1,
                    f: 1,
                    no: 1,
                    zr: 0,
                    ng: 0
                }
            ),
            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0]
        );
        assert_eq!(
            ALU(
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1],
                &mut ControlBits {
                    zx: 1,
                    nx: 1,
                    zy: 0,
                    ny: 1,
                    f: 1,
                    no: 1,
                    zr: 0,
                    ng: 0
                }
            ),
            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0]
        );
        assert_eq!(
            ALU(
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1],
                &mut ControlBits {
                    zx: 0,
                    nx: 0,
                    zy: 1,
                    ny: 1,
                    f: 1,
                    no: 0,
                    zr: 0,
                    ng: 0
                }
            ),
            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0]
        );
        assert_eq!(
            ALU(
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1],
                &mut ControlBits {
                    zx: 1,
                    nx: 1,
                    zy: 0,
                    ny: 0,
                    f: 1,
                    no: 0,
                    zr: 0,
                    ng: 0
                }
            ),
            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0]
        );
        assert_eq!(
            ALU(
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1],
                &mut ControlBits {
                    zx: 0,
                    nx: 0,
                    zy: 0,
                    ny: 0,
                    f: 1,
                    no: 0,
                    zr: 0,
                    ng: 0
                }
            ),
            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0]
        );
        assert_eq!(
            ALU(
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1],
                &mut ControlBits {
                    zx: 0,
                    nx: 1,
                    zy: 0,
                    ny: 0,
                    f: 1,
                    no: 1,
                    zr: 0,
                    ng: 0
                }
            ),
            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0]
        );
        assert_eq!(
            ALU(
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1],
                &mut ControlBits {
                    zx: 0,
                    nx: 0,
                    zy: 0,
                    ny: 1,
                    f: 1,
                    no: 1,
                    zr: 0,
                    ng: 0
                }
            ),
            vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0]
        );
        assert_eq!(
            ALU(
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1],
                &mut ControlBits {
                    zx: 0,
                    nx: 0,
                    zy: 0,
                    ny: 0,
                    f: 0,
                    no: 0,
                    zr: 0,
                    ng: 0
                }
            ),
            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]
        );
        assert_eq!(
            ALU(
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1],
                &vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1],
                &mut ControlBits {
                    zx: 0,
                    nx: 1,
                    zy: 0,
                    ny: 1,
                    f: 0,
                    no: 1,
                    zr: 0,
                    ng: 0
                }
            ),
            vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1]
        );
    }

    #[test]
    fn test_is_equal() {
        assert_eq!(
            is_zero(&vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]),
            1
        );
        assert_eq!(
            is_zero(&vec![0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1]),
            0
        );
        assert_eq!(
            is_zero(&vec![1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]),
            0
        );
    }

    #[test]
    fn test_bit() {
        let mut dff = DFF::new();
        let input = 0;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 1;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 1;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 1;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 1;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 1;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 1;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 1;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 1;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 0;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 1;
        let out = 1;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 0;
        let load = 1;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
        let input = 1;
        let load = 0;
        let out = 0;
        assert_eq!(dff.data, out);
        dff.cycle(input, load);
    }

    #[test]
    pub fn test_ram() {
        let mut ram = crate::hardware::native::memory::RAM::new();

        let input = 0;
        let load = 0;
        let address = 0;
        assert_eq!(ram.data[address as usize], 0);
        ram.cycle(input, address, load);
        let input = 0;
        let load = 0;
        let address = 0;
        assert_eq!(ram.data[address as usize], 0);
        ram.cycle(input, address, load);
        let input = 0;
        let load = 1;
        let address = 0;
        assert_eq!(ram.data[address as usize], 0);
        ram.cycle(input, address, load);
        let input = 0;
        let load = 1;
        let address = 0;
        assert_eq!(ram.data[address as usize], 0);
        ram.cycle(input, address, load);
        let input = 4321;
        let load = 0;
        let address = 0;
        assert_eq!(ram.data[address as usize], 0);
        ram.cycle(input, address, load);
        let input = 4321;
        let load = 0;
        let address = 0;
        assert_eq!(ram.data[address as usize], 0);
        ram.cycle(input, address, load);
        let input = 4321;
        let load = 1;
        let address = 4321;
        assert_eq!(ram.data[address as usize], 0);
        ram.cycle(input, address, load);
        let input = 4321;
        let load = 1;
        let address = 4321;
        assert_eq!(ram.data[address as usize], 4321);
        ram.cycle(input, address, load);
        let input = 4321;
        let load = 0;
        let address = 0;
        assert_eq!(ram.data[address as usize], 0);
        ram.cycle(input, address, load);
        let input = 4321;
        let load = 0;
        let address = 0;
        assert_eq!(ram.data[address as usize], 0);
        ram.cycle(input, address, load);
        let input = 12345;
        let load = 0;
        let address = 12345;
        assert_eq!(ram.data[address as usize], 0);
        ram.cycle(input, address, load);
        let input = 12345;
        let load = 0;
        let address = 12345;
        assert_eq!(ram.data[address as usize], 0);
        ram.cycle(input, address, load);
        let input = 12345;
        let load = 1;
        let address = 12345;
        assert_eq!(ram.data[address as usize], 0);
        ram.cycle(input, address, load);
        let input = 12345;
        let load = 1;
        let address = 12345;
        assert_eq!(ram.data[address as usize], 12345);
        ram.cycle(input, address, load);
        let input = 12345;
        let load = 0;
        let address = 12345;
        assert_eq!(ram.data[address as usize], 12345);
        ram.cycle(input, address, load);
        let input = 12345;
        let load = 0;
        let address = 12345;
        assert_eq!(ram.data[address as usize], 12345);
        ram.cycle(input, address, load);
        let input = 12345;
        let load = 0;
        let address = 4321;
        assert_eq!(ram.data[address as usize], 4321);
        ram.cycle(input, address, load);
        let input = 16383;
        let load = 0;
        let address = 4321;
        assert_eq!(ram.data[address as usize], 4321);
        ram.cycle(input, address, load);
        let input = 16383;
        let load = 0;
        let address = 4321;
        assert_eq!(ram.data[address as usize], 4321);
        ram.cycle(input, address, load);
        let input = 16383;
        let load = 1;
        let address = 16383;
        assert_eq!(ram.data[address as usize], 0);
        ram.cycle(input, address, load);
        let input = 16383;
        let load = 1;
        let address = 16383;
        assert_eq!(ram.data[address as usize], 16383);
        ram.cycle(input, address, load);
        let input = 16383;
        let load = 0;
        let address = 16383;
        assert_eq!(ram.data[address as usize], 16383);
        ram.cycle(input, address, load);
        let input = 16383;
        let load = 0;
        let address = 16383;
        assert_eq!(ram.data[address as usize], 16383);
        ram.cycle(input, address, load);
        let input = 16383;
        let load = 0;
        let address = 12345;
        assert_eq!(ram.data[address as usize], 12345);
        ram.cycle(input, address, load);
        let input = 16383;
        let load = 0;
        let address = 16383;
        assert_eq!(ram.data[address as usize], 16383);
        ram.cycle(input, address, load);
        let input = 16383;
        let load = 0;
        let address = 10920;
        assert_eq!(ram.data[address as usize], 0);
        ram.cycle(input, address, load);
        let input = 16383;
        let load = 0;
        let address = 10920;
        assert_eq!(ram.data[address as usize], 0);
        ram.cycle(input, address, load);
        let input = 16383;
        let load = 0;
        let address = 10921;
        assert_eq!(ram.data[address as usize], 0);
        ram.cycle(input, address, load);
        let input = 16383;
        let load = 0;
        let address = 10922;
        assert_eq!(ram.data[address as usize], 0);
        ram.cycle(input, address, load);
        let input = 16383;
        let load = 0;
        let address = 10923;
        assert_eq!(ram.data[address as usize], 0);
        ram.cycle(input, address, load);
        let input = 16383;
        let load = 0;
        let address = 10924;
        assert_eq!(ram.data[address as usize], 0);
        ram.cycle(input, address, load);
        let input = 16383;
        let load = 0;
        let address = 10925;
        assert_eq!(ram.data[address as usize], 0);
        ram.cycle(input, address, load);
        let input = 16383;
        let load = 0;
        let address = 10926;
        assert_eq!(ram.data[address as usize], 0);
        ram.cycle(input, address, load);
        let input = 16383;
        let load = 0;
        let address = 10927;
        assert_eq!(ram.data[address as usize], 0);
        ram.cycle(input, address, load);
        let input = 21845;
        let load = 1;
        let address = 10920;
        assert_eq!(ram.data[address as usize], 0);
        ram.cycle(input, address, load);
        let input = 21845;
        let load = 1;
        let address = 10920;
        assert_eq!(ram.data[address as usize], 21845);
        ram.cycle(input, address, load);
        let input = 21845;
        let load = 1;
        let address = 10921;
        assert_eq!(ram.data[address as usize], 0);
        ram.cycle(input, address, load);
        let input = 21845;
        let load = 1;
        let address = 10921;
        assert_eq!(ram.data[address as usize], 21845);
        ram.cycle(input, address, load);
        let input = 21845;
        let load = 1;
        let address = 10922;
        assert_eq!(ram.data[address as usize], 0);
        ram.cycle(input, address, load);
        let input = 21845;
        let load = 1;
        let address = 10922;
        assert_eq!(ram.data[address as usize], 21845);
        ram.cycle(input, address, load);
        let input = 21845;
        let load = 1;
        let address = 10923;
        assert_eq!(ram.data[address as usize], 0);
        ram.cycle(input, address, load);
        let input = 21845;
        let load = 1;
        let address = 10923;
        assert_eq!(ram.data[address as usize], 21845);
        ram.cycle(input, address, load);
    }

    #[test]
    fn test_cpu() {
        let mut comp = Computer::new(vec![
            0b0000000000000000,
            0b1111110000010000,
            0b0000000000000001,
            0b1111010011010000,
            0b0000000000001010,
            0b1110001100000001,
            0b0000000000000001,
            0b1111110000010000,
            0b0000000000001100,
            0b1110101010000111,
            0b0000000000000000,
            0b1111110000010000,
            0b0000000000000010,
            0b1110001100001000,
            0b0000000000001110,
            0b1110101010000111,
        ]);
        comp.ram.data[0] = 3;
        comp.ram.data[1] = 5;

        comp.execute(true, false);
        assert_eq!(
            (
                int_from_bitvec(&comp.a.data),
                i16::from_ne_bytes(int_from_bitvec(&comp.d.data).to_ne_bytes()),
                int_from_bitvec(&comp.pc.val.data),
                comp.ram.data[0],
                comp.ram.data[1],
                comp.ram.data[2]
            ),
            (0, 0, 1, 3, 5, 0)
        );
        comp.execute(true, false);
        assert_eq!(
            (
                int_from_bitvec(&comp.a.data),
                i16::from_ne_bytes(int_from_bitvec(&comp.d.data).to_ne_bytes()),
                int_from_bitvec(&comp.pc.val.data),
                comp.ram.data[0],
                comp.ram.data[1],
                comp.ram.data[2]
            ),
            (0, 3, 2, 3, 5, 0)
        );
        comp.execute(true, false);
        assert_eq!(
            (
                int_from_bitvec(&comp.a.data),
                i16::from_ne_bytes(int_from_bitvec(&comp.d.data).to_ne_bytes()),
                int_from_bitvec(&comp.pc.val.data),
                comp.ram.data[0],
                comp.ram.data[1],
                comp.ram.data[2]
            ),
            (1, 3, 3, 3, 5, 0)
        );
        comp.execute(true, false);
        assert_eq!(
            (
                int_from_bitvec(&comp.a.data),
                i16::from_ne_bytes(int_from_bitvec(&comp.d.data).to_ne_bytes()),
                int_from_bitvec(&comp.pc.val.data),
                comp.ram.data[0],
                comp.ram.data[1],
                comp.ram.data[2]
            ),
            (1, -2, 4, 3, 5, 0)
        );
        comp.execute(true, false);
        assert_eq!(
            (
                int_from_bitvec(&comp.a.data),
                i16::from_ne_bytes(int_from_bitvec(&comp.d.data).to_ne_bytes()),
                int_from_bitvec(&comp.pc.val.data),
                comp.ram.data[0],
                comp.ram.data[1],
                comp.ram.data[2]
            ),
            (10, -2, 5, 3, 5, 0)
        );
        comp.execute(true, false);
        assert_eq!(
            (
                int_from_bitvec(&comp.a.data),
                i16::from_ne_bytes(int_from_bitvec(&comp.d.data).to_ne_bytes()),
                int_from_bitvec(&comp.pc.val.data),
                comp.ram.data[0],
                comp.ram.data[1],
                comp.ram.data[2]
            ),
            (10, -2, 6, 3, 5, 0)
        );
        comp.execute(true, false);
        assert_eq!(
            (
                int_from_bitvec(&comp.a.data),
                i16::from_ne_bytes(int_from_bitvec(&comp.d.data).to_ne_bytes()),
                int_from_bitvec(&comp.pc.val.data),
                comp.ram.data[0],
                comp.ram.data[1],
                comp.ram.data[2]
            ),
            (1, -2, 7, 3, 5, 0,)
        );
        comp.execute(true, false);
        assert_eq!(
            (
                int_from_bitvec(&comp.a.data),
                i16::from_ne_bytes(int_from_bitvec(&comp.d.data).to_ne_bytes()),
                int_from_bitvec(&comp.pc.val.data),
                comp.ram.data[0],
                comp.ram.data[1],
                comp.ram.data[2]
            ),
            (1, 5, 8, 3, 5, 0)
        );
        comp.execute(true, false);
        assert_eq!(
            (
                int_from_bitvec(&comp.a.data),
                i16::from_ne_bytes(int_from_bitvec(&comp.d.data).to_ne_bytes()),
                int_from_bitvec(&comp.pc.val.data),
                comp.ram.data[0],
                comp.ram.data[1],
                comp.ram.data[2]
            ),
            (12, 5, 9, 3, 5, 0)
        );
        comp.execute(true, false);
        assert_eq!(
            (
                int_from_bitvec(&comp.a.data),
                i16::from_ne_bytes(int_from_bitvec(&comp.d.data).to_ne_bytes()),
                int_from_bitvec(&comp.pc.val.data),
                comp.ram.data[0],
                comp.ram.data[1],
                comp.ram.data[2]
            ),
            (12, 5, 12, 3, 5, 0)
        );
        comp.execute(true, false);
        assert_eq!(
            (
                int_from_bitvec(&comp.a.data),
                i16::from_ne_bytes(int_from_bitvec(&comp.d.data).to_ne_bytes()),
                int_from_bitvec(&comp.pc.val.data),
                comp.ram.data[0],
                comp.ram.data[1],
                comp.ram.data[2]
            ),
            (2, 5, 13, 3, 5, 0)
        );
        comp.execute(true, false);
        assert_eq!(
            (
                int_from_bitvec(&comp.a.data),
                i16::from_ne_bytes(int_from_bitvec(&comp.d.data).to_ne_bytes()),
                int_from_bitvec(&comp.pc.val.data),
                comp.ram.data[0],
                comp.ram.data[1],
                comp.ram.data[2]
            ),
            (2, 5, 14, 3, 5, 5,)
        );
        comp.execute(true, false);
        assert_eq!(
            (
                int_from_bitvec(&comp.a.data),
                i16::from_ne_bytes(int_from_bitvec(&comp.d.data).to_ne_bytes()),
                int_from_bitvec(&comp.pc.val.data),
                comp.ram.data[0],
                comp.ram.data[1],
                comp.ram.data[2]
            ),
            (14, 5, 15, 3, 5, 5)
        );
        comp.execute(true, false);
        assert_eq!(
            (
                int_from_bitvec(&comp.a.data),
                i16::from_ne_bytes(int_from_bitvec(&comp.d.data).to_ne_bytes()),
                int_from_bitvec(&comp.pc.val.data),
                comp.ram.data[0],
                comp.ram.data[1],
                comp.ram.data[2]
            ),
            (14, 5, 14, 3, 5, 5)
        );
        comp.execute(true, true);
        assert_eq!(
            (
                int_from_bitvec(&comp.a.data),
                i16::from_ne_bytes(int_from_bitvec(&comp.d.data).to_ne_bytes()),
                int_from_bitvec(&comp.pc.val.data),
                comp.ram.data[0],
                comp.ram.data[1],
                comp.ram.data[2]
            ),
            (14, 5, 0, 3, 5, 5)
        );
        comp.ram.data[0] = 23456;
        comp.ram.data[1] = 12345;
        assert_eq!(
            (
                int_from_bitvec(&comp.a.data),
                i16::from_ne_bytes(int_from_bitvec(&comp.d.data).to_ne_bytes()),
                int_from_bitvec(&comp.pc.val.data),
                comp.ram.data[0],
                comp.ram.data[1],
                comp.ram.data[2]
            ),
            (14, 5, 0, 23456, 12345, 5)
        );
        comp.execute(true, false);
        assert_eq!(
            (
                int_from_bitvec(&comp.a.data),
                i16::from_ne_bytes(int_from_bitvec(&comp.d.data).to_ne_bytes()),
                int_from_bitvec(&comp.pc.val.data),
                comp.ram.data[0],
                comp.ram.data[1],
                comp.ram.data[2]
            ),
            (0, 5, 1, 23456, 12345, 5)
        );
        comp.execute(true, false);
        assert_eq!(
            (
                int_from_bitvec(&comp.a.data),
                i16::from_ne_bytes(int_from_bitvec(&comp.d.data).to_ne_bytes()),
                int_from_bitvec(&comp.pc.val.data),
                comp.ram.data[0],
                comp.ram.data[1],
                comp.ram.data[2]
            ),
            (0, 23456, 2, 23456, 12345, 5)
        );
        comp.execute(true, false);
        assert_eq!(
            (
                int_from_bitvec(&comp.a.data),
                i16::from_ne_bytes(int_from_bitvec(&comp.d.data).to_ne_bytes()),
                int_from_bitvec(&comp.pc.val.data),
                comp.ram.data[0],
                comp.ram.data[1],
                comp.ram.data[2]
            ),
            (1, 23456, 3, 23456, 12345, 5)
        );
        comp.execute(true, false);
        assert_eq!(
            (
                int_from_bitvec(&comp.a.data),
                i16::from_ne_bytes(int_from_bitvec(&comp.d.data).to_ne_bytes()),
                int_from_bitvec(&comp.pc.val.data),
                comp.ram.data[0],
                comp.ram.data[1],
                comp.ram.data[2]
            ),
            (1, 11111, 4, 23456, 12345, 5)
        );
        comp.execute(true, false);
        assert_eq!(
            (
                int_from_bitvec(&comp.a.data),
                i16::from_ne_bytes(int_from_bitvec(&comp.d.data).to_ne_bytes()),
                int_from_bitvec(&comp.pc.val.data),
                comp.ram.data[0],
                comp.ram.data[1],
                comp.ram.data[2]
            ),
            (10, 11111, 5, 23456, 12345, 5)
        );
        comp.execute(true, false);
        assert_eq!(
            (
                int_from_bitvec(&comp.a.data),
                i16::from_ne_bytes(int_from_bitvec(&comp.d.data).to_ne_bytes()),
                int_from_bitvec(&comp.pc.val.data),
                comp.ram.data[0],
                comp.ram.data[1],
                comp.ram.data[2]
            ),
            (10, 11111, 10, 23456, 12345, 5,)
        );

        comp.execute(true, false);
        assert_eq!(
            (
                int_from_bitvec(&comp.a.data),
                i16::from_ne_bytes(int_from_bitvec(&comp.d.data).to_ne_bytes()),
                int_from_bitvec(&comp.pc.val.data),
                comp.ram.data[0],
                comp.ram.data[1],
                comp.ram.data[2]
            ),
            (0, 11111, 11, 23456, 12345, 5)
        );
        comp.execute(true, false);
        assert_eq!(
            (
                int_from_bitvec(&comp.a.data),
                i16::from_ne_bytes(int_from_bitvec(&comp.d.data).to_ne_bytes()),
                int_from_bitvec(&comp.pc.val.data),
                comp.ram.data[0],
                comp.ram.data[1],
                comp.ram.data[2]
            ),
            (0, 23456, 12, 23456, 12345, 5)
        );
        comp.execute(true, false);
        assert_eq!(
            (
                int_from_bitvec(&comp.a.data),
                i16::from_ne_bytes(int_from_bitvec(&comp.d.data).to_ne_bytes()),
                int_from_bitvec(&comp.pc.val.data),
                comp.ram.data[0],
                comp.ram.data[1],
                comp.ram.data[2]
            ),
            (2, 23456, 13, 23456, 12345, 5,)
        );
        comp.execute(true, false);
        assert_eq!(
            (
                int_from_bitvec(&comp.a.data),
                i16::from_ne_bytes(int_from_bitvec(&comp.d.data).to_ne_bytes()),
                int_from_bitvec(&comp.pc.val.data),
                comp.ram.data[0],
                comp.ram.data[1],
                comp.ram.data[2]
            ),
            (2, 23456, 14, 23456, 12345, 23456)
        );
    }
}
